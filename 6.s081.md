# XV6 book

## 1 Operating system interfaces

### 	1.1 processes and memory

Xv6的time-shares proocesses :它在等待执行的一组进程之间透明地切换可用的CPU。当一个进程没有执行时，CPU锁住它的cpu寄存器，下次运行时再restoring（恢复）。

fork（）系统调用可以复制一个与自己相同的子进程，叫做child，而自己叫做parent。尽管子级最初与父级具有相同的内存内容（memory contents），但父级和子级使用不同的内存和不同的寄存器执行：更改其中一个变量不会影响另一个变量。

exec（）系统调用将调用进程的内存替换为从文件系统中存储的文件加载的新内存映像。（大概就是用新的内存替换掉现在的内存）。文件必须包含特定的格式（哪部分是数据，哪部分开始）。包含两个参数：1、可执行文件的名称  2、 字符串数组。

>  main()函数 –> getcmd(read a line) – > fork() 
>
> 父：wait（）  子: runcmd() -> exec() -> exit() -> 父
>
> 这是因为子进程的IO可以重定向而不会干扰主进程的IO

### 	1.2 I/O  and File descriptors

io和文件描述符

文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象。0：输入， 1：输出， 2：输出错误。

read()和write()每一个指向文件的文件描述符都和一个偏移关联。`read` 从当前文件偏移处读取数据，然后把偏移增加读出字节数。紧随其后的 `read` 会从新的起点开始读数据。当没有数据可读时，`read` 就会返回0，这就表示文件结束了。

close()释放文件描述符。一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。

文件描述符和fork使得IO重定向简单。`fork` 会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。`exec` 会替换调用它的进程的内存但是会保留它的文件描述符表。这种行为使得 shell 可以这样实现重定向：`fork` 一个进程，重新打开指定文件的文件描述符，然后执行新的程序。

虽然 `fork`会复制文件描述符表，但是每个底层文件偏移量再父级和子级之间共享。有利于顺序输出。

```c
if(fork()==0){
write(1,"hello ",6);
exit(0);
}
else{
wait(0);
write(1, "world ",6);
}
```

最后会输出 hello world 。

`dup`系统调用复制文件描述符，也共享文件偏移。从同一个原初文件描述符通过一系列 `fork` 和 `dup` 调用产生的文件描述符都共享同一个文件偏移，其它就不可以。

### 	1.3 Pipes

管道是一个小的内存缓冲区，它有两端，一端写操作，一端读操作。

与temporary files 的四个优点：

1. 会自动清理 ，文件重定向需要shell小心的删除 /temp/xyz    
2. pipe 可以传递任意长度的数据流，而文件重定向需要足够的可能空间来存储数据。 
3. pipe允许并行，而文件重定向需要1->2  
4. 如果你正在实现进程间的通信， pipe的阻塞读写比文件的非阻塞语义更有效。

### 	1.4 File system



# Introduction and examples

## lecture **goals：**

- 操作系统的设计
- xv6系统示例

## **os purposes**

	- 抽象的硬件
	- 多路复用，同时执行多项任务
	- 不同的活动不相互干扰
	- 共享
	- 安全
	- 好的表现

## **os org：**

User space：VI、CC、SH

Kernel：（计算机启动首先启动的程序）：内置了一些服务，

- 比如文件系统的实现，
- 还有进程的管理（CPU内存的管理，不同进程的分配）
- 访问控制（权限）
- 还有其他一大堆：TCP、IP、不同的进程之间的通信
-  ==os课关注kernel层，以及与user space 的接口，以及kernel的内部软件的结构类型==

下一层：CPU、RAM、DISK、NET

## API kernel

应用程序如何方位kernel：通过系统调用（类似于函数调用）的实现, 与函数调用不同的是，kernel可以有特权访问硬件

- fd = open(“out”,1),  fd 是文件描述符
- write(fd,”hello\n”,6)
- fork是创建系统的调用：  pid: = fork();  副本

c语言的open 和系统调用的open有何不同： c的open是通过函数调用到汇编指令，然后汇编指令在通过kernel来管理内存和进程。

![image-20231021200645432](https://raw.githubusercontent.com/kakarotto007/final/master/image-20231021200645432.png)

## lab 0

